# 数学（杂题

`Nothing can fuck you harder than math...`

---
layout: image
image: ./pics/LRChat.png
---

---
layout: center
---

那我大概了解，就是：
- 计数黑题
- 概率黑题
- 现代深入
- 生成函数黑题
- 反演黑题
- 特殊数偏难怪

所以今天讲点抽象题！

---

## 简单问题

- [Jzzhu and Numbers](https://codeforces.com/contest/449/problem/D)

给出一个长度为 $n \le 10^6$ 的序列 $a_i$​。求构造出一个序列 $i_1 \lt i_2 \lt \cdots \lt i_k$ 使得 $a_{i_1}$ & $a_{i_2}$ & $\cdots$ & $a_{i_k} = 0$（其中 & 表示按位与）的方案数模 $10^9 + 7$ 。

也就是从 $a_i$ 里面选出一个非空子集使这些数按位与起来为 $0$。

---

为 $0$ 的不好求，考虑求非 $0$ 的。

<v-clicks>

考虑设 $f_x$ 表示 $a_i$ & $x = x$ 的数的个数。

那么简单容斥一下：

$$
\sum_x (-1)^{\mathrm{popcount(x)}} f_x
$$

至于 $f_x$ 递推即可。

</v-clicks>

---

- [Speedbreaker](https://www.luogu.com.cn/problem/CF2018B)

有一排 $n$ 个城市，编号 $1 \sim n$，第一时间，可以随意占领一个城（起始城市），此后每一个时间只能占领已占领的相邻的城的其中一个。

要求每个城不能晚于 $t_i$ 被占领。

求：

1. 那些城市作为起始城市可以完全占领（称为赢城）？（$n \le 10^5$）
2. 在 $1 \le t_i \le n$ 的限制下，计算赢城有 $0 \sim n$ 个的方案数。($n \le 500$，取模且不可用 NTT)

---

P1 hint:

<v-clicks>

1. 可行的区间一定被包含于 $I = \bigcap_i (i - a_i, i + a_i)$
2. 答案一定是连续的
3. 答案要么是 $I$ 要么是 $\empty$

</v-clicks>

<v-clicks>

证明（感性，因为我不会严谨）：

1. 在存在解的情况下 $I$ 两侧的限制一定是最强的（直接锁死方向），也就是从两端出发必须要另一端一路进发。故而如果从中间开始，可以提前到达一端，满足该端限制。在有解的情况下，从端点出发，走的过程中会占领某个城市，使得另一侧的限制变宽松，否则无解，所以提前出发 = 提前放松限制，故答案一定连续。

2. 在 $I$ 外的一定不行，所以如果 $I$ 内存在一个起点不行，意味着走的过程中总是无法足够的放松限制，否则根据 1，一定可行，那么答案要么是 $I$ 要么是 $\empty$。（或者说，可以说明，构造的策略要走完 $I$ 内所有元素，再向外扩展。

于是只需要判断有无解即可。利用类似 CSP-S2023 种树的 Trick 也好，利用官方题解的两种构造也好，模拟一遍即可。

</v-clicks>

---

![](./pics/CF2018B%20Speedbreaker%20strcmp%20Sol.png)

---

接下来考虑计数的问题。

~~这题我是真搞不明白，饶了我吧~~

---

- [DZY Loves Games](codeforces.com/problemset/problem/446/D)

DZY开始玩一种古老的游戏。 在这个游戏中，他将处于一个巨大的迷宫中，迷宫中有n个房间，由m条走廊相连接（每个走廊允许向两个方向移动）。你可以假设所有房间都直接或间接与走廊相连。
DZY迷失在迷宫中。 目前他在第一个房间，有k条命。 他的行为如下：
- 首先，他将随机挑选一条能走出当前所在房间的走廊。 每个走廊被挑选的概率相同。
- 然后，他会穿过走廊，然后重复这个过程。
有些房间里面有陷阱。 第一个房间肯定没有陷阱，但第n个房间肯定有一个陷阱。
每当DZY进入其中一个房间时，他就会失去一条命。 如果他进入第n个房间，只有恰好2条命的话，首先他将失去一条生命，但随后他将进入奖金回合。 他想知道他进入奖金回合的可能性有多大。

---

我们只需要知道只能走不超过 $k - 2$ 个除了 $n$ 之外的陷阱房。

那么我们找一找对于所有的陷阱房，直接从陷阱房 $i$ 到 $j$ 而不经过其他陷阱房（包括 $n$）的概率。利用 高消 算法即可，$O(n^3)$。还要找到每个陷阱房（包括 1）直接到 $n$ 而不经过其他陷阱房的概率 $D$

然后找到了该邻接矩阵 $M$，答案则是 $M^{k - 2} D$ 的某一项。

---

- [Segment Covering](https://codeforces.com/problemset/problem/1774/G)

给定 $n$ 个区间 $[x_i, y_i]$，保证所有区间均不同。令 $f(l, r)$ 表示从 $n$ 个区间中选择偶数个区间使得其求并集后恰为 $[l, r]$ 的方案数，令 $g(l, r)$ 表示从 $n$ 个区间中选择奇数个区间使得其求并集后恰为 $[l, r]$ 的方案数。给定 $q$ 组询问 $[l_i, r_i]$，输出 $f(l, r)-g(l, r)$，对 $998244353$ 取模。

---

hint:

<v-clicks>

1. 如果存在线段满足 $A \subset B$，那么在选了 $B$ 的情况下，$A$ 可选可不选，对奇偶贡献相等，故 $B$ 可以被删除。于是转化为若干相交（但不包含）线段求解答案。
3. 答案一定在 $\{0, \pm 1\}$ 内。

</v-clicks>

<v-clicks>

开始考虑答案为 $0$ 怎么判断？这只需要判断是否能够刚好覆盖即可，这很简单。而答案为 $\pm 1$ 就要继续考虑性质。

![alt text](./pics/segmentCovering1.png)

发现线段 1 必须选，二类同 hint 1，如果 3 选了，那么 2 可选可不选，奇偶贡献相等，于是 3 删了便是。按此类推，2 必须选。

</v-clicks>

---

<v-clicks>

同理类推下去，最终必须选择的线段如图，其他不必选线段对答案没有贡献。

![alt text](./pics/segmentCovering2.png)

于是我们令 $f_i$ 表示最小的 $j$ 满足 $r_i \lt l_j$，在上下两部分利用 $f_i$ 不断向后跳即可算出线段的数量。

答案就是 $(-1)^k$。

当然有另一种在跳的过程中判断有无解的方法，考虑如果没有全覆盖，那么在断点之后，一定会跳到同一个线段上，也就是说最终都会跳到同一个线段上。据此便可以判断有无解了。


</v-clicks>

---

当然有另一种更数学一点的做法。

<v-clicks>

在 hint 1 的推论下，考虑如果直接求 $f, g$ 的暴力 DP 怎么做？（先离散化为端点）

$$
\begin{aligned}
f_{r_i} = \sum_{l_i \le r_j \lt r_i} g_{r_j} \\
g_{r_i} = \sum_{l_i \le r_j \lt r_i} h_{r_j} \\
\end{aligned}
$$

利用两式相减，$h = f - g$，则：

$$
h_{r_i} = \sum_{l_i \le r_j \lt r_i} -h_{r_j} \\
$$

换成前缀和，则：

$$
pre_i - pre_{i - 1} = - (pre_{i - 1} - pre_{L - 1}) \implies pre_i = pre_{L - 1}
$$

于是对于边界 $[L, R]$，则 $pre_{L - 1} = 0, pre_L = 1$。而对于一个 $i$ 其 $L$ 是容易预处理出来的，发现这就是倍增向后跳的形式。

</v-clicks>

---

- [Deducing Sortability](https://www.luogu.com.cn/problem/CF1725D)

![](./pics/CF1725D%20Deducing%20Sortability%20Problem.png)

---

```
1:
2: (2)
3: 4, (4)
4: 6, 8, (8)
5: 8, 12, 16, (16)
6: 10, 16, 24, 32, (32)
7: 12, 20, 32, 48, 64, (64)
8: 14, 24, 40, 64, 96, 128, (128)
9: 16, 28, 48, 80, 128, 192, 256, (256)
10: 18, 32, 56, 96, 160, 256, 384, 512, (512)
```

<v-clicks>

对于 $(x - 2^c) \times 2$ 暴力展开，可以发现 $k$ 次操作后，变成了 $2^k \times (x - k)$。

那么若要和最小，取数策略如下：

枚举 $i$，找操作后 $i$ 有多少个没有在前面出现过。

考虑到 $2^k \times (x - k) = 2^{k - 1} \times (2x - 1 - k - (k - 1))$ 也就是说 $x - k \equiv 1 \pmod 2$ 时 $2^k \times (x - k)$ 一定未出现。

</v-clicks>

---

<v-clicks>

打表观察：`(1, 1), (2, 2), (3, 3), (3, 4), (4, 6), (4, 8)`

发现很像若干个等差数列，并且公差为 $2^k$，考虑证明：

![alt text](./pics/CF1725D%20Deducing%20Sortability%20Problem%20Table.png)

(篇幅问题，开始口胡)

</v-clicks>

---

<v-clicks>

然后我们就可以知道每一个公差为 $2^k$ 的数列到底有多少个，询问的时候二分并还原即可。

（怎么还原？$O(\log n)$ 枚举 $k$ 找最小的 $x$ 是非常容易想到的。肯定有其他方法，自行探索喽


</v-clicks>

---
src: prob.md
---

---
src: finite-calculus.md
---

---

概率和有限微积分讲完了……

该反演了吗？

看 [炫酷反演魔术](https://vfleaking.blog.uoj.ac/slide/87#/13) 即可，咕。

作业：[集训队作业2018 复读机](https://uoj.ac/problem/450)

然后我们进入终章。
