# 数据结构

## 队列

Baka's Trick 讲过了，所以就没什么可以说的了。

## 栈

单调栈用来建笛卡尔树相信大家都会，所以也没什么可以说的了。

## 链表

最可能用到链表的就是离线静态前驱后继，这个也是大家都会所以不说了。

## 线段树

~~我喜欢这个，所以我要讲。~~

NOIP 如果考数据结构几乎必考线段树，所以这个就乱七八糟都讲讲吧。

### EAZY

#### Rmq Problem / mex

求区间 $mex$。

$n,q\leq2\times10^5$。







#### Sol

设 $f_{i,j}$ 表示最大的 $k$ 满足 $k\leq i\and a_k=j$，若不存在就等于 0，那么对于一个询问 $[l,r]$，就是要求最小的 $k$ 满足 $f_{r,k}<l$。

$f_{i,j}$ 可以用主席树维护，回答询问只需要在主席树上二分即可。

可以离线的话也可以扫描线，降低空间复杂度。

$O(n\log n)$。





#### P4898 [IOI2018] seats **排座位**

有 $n$ 个人，每个人与一个 $r\times c$ 的矩阵的每一个位置一一对应，记为 $x_i,y_i$。

要求支持交换两个人的位置，以及查询有多少个前缀，使得这些人在矩阵中的位置刚好构成一个子矩阵。

$n=r\times c\leq10^6$。







#### Sol

一个普通的想法就是维护前缀的 $x,y$ 的 $min,max$，然后检查面积对不对的上。

但是这样的问题在于交换两个人的坐标之后，这个变化可能是 $O(n)$ 的，没有办法很好的维护。



我们可以采用另一个方法来描述一个前缀是否合法：考虑 $i$ 的前缀的人染成黑色，其他人染成白色，记 $s_i$ 表示有多少个黑点左上是白点，$t_i$ 表示有多少个白点周围至少有两个黑点；那么一个前缀合法当且仅当 $s_i=1\and t_i=0$。

交换两人之后发现只有 $O(1)$ 的改变，所以直接线段树维护 $s_i+t_i$，然后支持区间修改以及查询最小值和最小值个数即可。



#### P11071 「QMSOI R1」 Distorted Fate

区间异或，查询区间每个前缀的按位或之和的和，即 $\sum_{i=l}^r\cup_{j=l}^ia_j$。

$n,q\leq2\times10^5$

3s, 100MB









#### Sol

一个很 naive 的想法就是直接每一位分开考虑贡献，那就是需要做区间 01 反转和查询区间里的第一个 1，那么维护一下区间里 $1$ 的个数就可以做到时间 $O(n\log^2n)$，空间 $O(n\log n)$，此处空间超过了限制。

一个很无脑的想法就是只存区间里是否有 1，但是修改就没办法维护了。

考虑维护区间里是否全是 1/ 是否全是 0/ 既有 0 又有 1，那么再维护一个 lazytag，事实上就可以维护了。那么把这些 bool 压进 bitset 里，就能把空间做到 $O(\frac{n\log n}\omega)$。

事实上还有跟那啥的做法，因为没有强制在线所以可以直接每一位分别做完再合并答案再输出，那么线段树就可以复用，只需要一颗线段树就够了，空间复杂度就是 $O(n)$，不过时间复杂度的常数会大一些。





### NORMAL

#### P4556 [Vani有约会] 雨天的尾巴 /【模板】线段树合并

给一棵树，每次操作形如在 x 到 y 的链上每个节点上放 k 个物品 w，所有操作完之后回答每个节点上个数最多的物品。

$n,q\leq10^5$。









#### Sol

线段树合并模板题。

如果有人不会就再讲吧。







#### P10641 BZOJ3252 攻略

给定一棵树，每个点有一个点权，要选择 $k$ 个叶子节点，使得这些点到根的路径的并集的点权和尽量大。

$n,k\leq2\times10^5$。











#### Sol

容易想到一个贪心，每次选择到根路径和最大的，然后再把这些点权值改为 0，重复 $k$ 次。

如果直接树剖的话，非常不优美。

考虑每个节点维护一个可重集合，表示这个点的子树内这样取，每次取出来的路径依次为哪些。

合并的时候就是把这子树的集合合并起来，然后把最大的那个值加上当前点的点权。

可以使用可并堆维护，当然也可以使用值域线段树，不过空间复杂度会变成 $O(n\log n)$。





#### P5298 [PKUWC2018] Minimax

小 $C$ 有一棵 $n$ 个结点的有根树，根是 $1$ 号结点，且每个结点最多有两个子结点。

定义结点 $x$ 的权值为：

1.若 $x$ 没有子结点，那么它的权值会在输入里给出，**保证这类点中每个结点的权值互不相同**。

2.若 $x$ 有子结点，那么它的权值有 $p_x$ 的概率是它的子结点的权值的最大值，有 $1-p_x$ 的概率是它的子结点的权值的最小值。

现在小 $C$ 想知道，假设 $1$ 号结点的权值有 $m$ 种可能性，**权值第 $i$ 小**的可能性的权值是 $V_i$，它的概率为 $D_i(D_i>0)$，求：

$$\sum_{i=1}^{m}i\cdot V_i\cdot D_i^2$$

对 $998244353$ 取模。

 $1\leq n\leq 3\times 10^5$。











#### Sol

一个显然的 dp 就是设 $f_{u,i}$ 表示 $u$ 的权值为 $i$ 的概率。

记 $l,r$ 为 $u$ 的左右儿子，那么有 $f_{u,i}=(1-p_u)(f_{l,i}\sum\limits_{j\leq i}f_{r,j}+f_{r,i}\sum\limits_{j\leq i}f_{l,j})+p_u(f_{l,i}\sum\limits_{j\geq i}f_{r,j}+f_{r,i}\sum\limits_{j\geq i}f_{l,j})$。

如果直接使用文艺平衡树进行启发式合并就可以做到 $O(n\log^2n)$ 了，但是我们可以使用线段树合并做到更加优美的 $O(n\log n)$。



### HARD

#### P10856 【MX-X2-T5】「Cfz Round 4」Xor-Forces

保证 $n$ 是 2 的幂。每次操作给 $x$ 把所有数 $a_i$ 挪到 $a_{i\otimes x}$，支持查询区间 $[l,r]$ 中的颜色段数。

$n\leq2^{18},q\leq2\times10^5$。











#### Sol

注意到操作具有结合律，每次都相当于原序列上进行一次修改。

一个很显然的转化就是颜色段数等于相邻两个不同色的对数。

考虑对当前序列建一个线段树，那么一个节点对应区间 $[l,r]$ 异或上一个 $x$ 后的答案可以预处理，但是这样就是搞笑的 $O(n^2)$。

发现一件很神秘的事情，$[l,r]$ 异或上 $x$ 的话，注意到 $l,r$ 的二进制有一段公共前缀，而中间每个数异或上 $x$ 的话，这个前缀也都是一起变的，实际上如果 x 有高位的话，$[l,r]$ 异或 $x$ 的答案实际上就是 $[l',r']$ 异或上 $x'$ 的答案。因此每个区间只需要维护区间长度那么多 $x$ 的答案即可。总复杂度 $O(n\log n)$。





#### P5210 [ZJOI2017] 线段树

给定一棵广义线段树，记 $S(l,r)$ 表示区间查询 $l,r$ 时发生了 return 的那些节点，多次给定 $l,r,u$ 询问 $\sum\limits_{v\in S(l,r)}dis(u,v)$。

$n,q\leq2\times10^5$。













#### Sol

注意到 $S(l,r)$ 事实上是两部分节点：$l$ 到根路径上所有节点的不在这个链上的右儿子以及 $r$ 到根路径上所有节点的不在这个链上的左儿子。

好像可以强上数据结构，但是很抽象，不考虑了。

联想到求树上一条链上所有点到一个点的距离和的那个分类讨论，这里我们也可以进行分类讨论，然后分类讨论秒了。







### ?

#### P10833 [COTS/CETS 2023] 下 Niz

给定一个序列，求有多少个子区间刚好是一个排列。

$n\leq10^6$。















#### Sol

直接分治，每次分治中心选择最大值，那么如果枚举了一个端点，那么另一个端点就确定了。

因此我们选择较小的那一边进行枚举，然后递归下去。

如果记 $g_i$ 表示最大的 $j$ 满足 $j<i\and a_j=a_i$，若不存在则等于 0，那么一个区间合法等价于 $\forall_{l\leq i\leq r}g_i<l$，于是可以使用 st 表 $O(1)$ 查询。

可以发现这个复杂度跟启发式合并非常类似，因此复杂度为 $O(n\log n)$。





### EX

#### CF301D Yaroslav and Divisors

给定一个排列，多次求区间 $l,r$ 中有多少数对是倍数关系。

$n,q\leq2\times10^5$















#### Sol

注意到可能成为答案的数对只有 $O(n\log n)$ 对，直接拿出来二维数点即可，总复杂度 $O(n\log^2 n)$。





#### CF1946F Nobody is needed

给定一个排列，多次询问区间 $l,r$ 中有多少个子序列满足后一个数是前一个数的倍数。

$n,q\leq10^6$

6s















#### Sol

考虑设 $f_{i,j}$ 表示以 $i$ 为起点，$j$ 为终点的合法子序列个数，那么转移就是 $f_{i,j}=\sum\limits_{i<k<j\and a_i|a_k}{f_{k,j}}$。

注意到有用的状态数只有 $O(n\log n)$ 种，有用的转移数只有 $O(n\log^2n)$ 种，因此直接暴力求出所有有用的状态，然后又变成了二维数点，总复杂度 $O(n\log^2 n)$，相当优美。