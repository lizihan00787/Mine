# 动态规划

动态规划是一种通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。

由于动态规划并不是某种具体的算法，而是一种解决特定问题的方法，因此它会出现在各式各样的数据结构中，与之相关的题目种类也更为繁杂。

### 引入：[IOI1994 数字三角形](https://www.luogu.com.cn/problem/P1216)

给定一个 $r$ 行的数字三角形($r\leq 1000$)，需要找到一条从最高点到底部任意处结束的路径，使路径经过数字的和最大。每一步可以走到当前点左下方的点或右下方的点。

~~~
        7 
      3   8 
    8   1   0 
  2   7   4   4 
4   5   2   6   5 
在上面这个例子中，最优路径是 7,3,8,7,5
~~~



最简单的思路是尝试所有的路径，但总路径数会有 $2^r$ 条，直接枚举复杂度爆炸。

但显然可以维护从根节点到每个节点的最大路径上权值和，下一步的决策只有两种：向左下或向右下，来更新后面两个点的最大权值。

如上题，动态规划即是通过把大问题分解为子问题并决策转移来缩减枚举量。

每一个点上都是结构相同的子问题，并且有对于其他子问题的转移。



动态规划的条件：

- 最优子结构：能够将大问题分解为若干个小问题，并且大问题的答案能够通过小问题的最优解构成。
- 无后效性：已经求解的子问题，不会再受到后续决策的影响。



基本思路：

- 将原问题划分为若干个阶段，每个阶段对应的子问题的特征（称为状态）
- 寻找每一个状态的可能决策，或者说是各状态间的相互转移方式（状态转移方程）
- 按照顺序依次求解问题。

本质上是状态对应节点，决策对应连边，变成一个有向无环图，在图上拓扑排序递推。



动态规划和递推有些相似（尤其是线性动规），但是不同于递推的是：

**递推求出的是数据，所以只是针对数据进行操作；而动态规划求出的是最优状态，所以必然也是针对状态的操作，而状态自然可以出现在最优解中，也可以不出现——这便是决策的特性（布尔性）。**

## 线性DP

### 最长上升子序列问题

给出一个由 $n(n\le 5000)$ 个不超过 $10^6$ 的正整数组成的序列。请输出这个序列的**最长上升子序列**的长度。

最长上升子序列是指，从原序列中**按顺序**取出一些数字排在一起，这些数字是**逐渐增大**的。



### Sol

定义 $f_i$ 为以 $a_i$ 为结尾的最长上升子序列长度， $f_i$ 由 $f_j(j\leq i且a_j<a_i)$ 转移过来。

状态转移方程：$f_i=max(f_j+1)$。

由这题可见某一个状态的最优解是由某上一个状态的最优解转移过来的。



### 最长公共子序列

给出 $1,2,\ldots,n$ 的两个排列 $P_1$ 和 $P_2$ ，求它们的最长公共子序列。

- 对于 $100\%$ 的数据， $n \le 10^5$。

~~~
输入：
5 
3 2 1 4 5
1 2 3 4 5
输出：
3
~~~







### Sol

令 $f_{i,j}$ 为 $P_1$ 前 $i$ 个数和 $P_2$ 前 $j$ 个数的最长公共子序列长度。

如果当前的$P1[i]$和$P2[j]$相同（即是有新的公共元素）那么：

$dp[ i ] [ j ] = max(dp[ i ] [ j ], dp[ i-1 ] [ j-1 ] + 1);$

如果不相同，即无法更新公共元素，考虑继承：

$dp[ i ] [ j ] = max(dp[ i-1 ][ j ] , dp[ i ][ j-1 ] $



但是这样只能过 $n^2$ 的数据。

$nlogn?$



## 背包

### 0-1背包

有 $N$ 件物品和一个容量为 $M$ 的背包。第 $i$ 件物品的重量是 $W_i$，价值是 $D_i$。求解将哪些物品装入背包可使这些物品的重量总和不超过背包容量，且价值总和最大。

$N,M<=1000$





### Sol

令$f_{i,j}$ 为考虑了前 $i$ 个物品，背包装了总重量为 $j$ 的物品的最大价值。

$ f_{i,j}=max(f_{i-1,j},f_{i-1,j-W_i}+D_i)$

代码用了滚动数组。

~~~
#include<bits/stdc++.h>
using namespace std;
int a[12881];
int c[3403],w[3403];
int n,m;
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>c[i]>>w[i];
	}
	for(int i=1;i<=n;i++){
		for(int u=m;u>=c[i];u--){
			a[u]=max(a[u],a[u-c[i]]+w[i]);
		}
	}
	cout<<a[m];
	return 0;
}
~~~

### 完全背包（P1616 疯狂的采药）

完全背包模型与 0-1 背包类似，与 0-1 背包的区别仅在于一个物品可以选取无限次，而非仅能选取一次。







### Sol

一般有两种做法：

- 将一种物品拆做多个物品，每种物品的价值和重量是原物品的 $2^k$。
- 第二种见代码：

~~~
#include<bits/stdc++.h>
using namespace std;
int a[12881];
int c[3403],w[3403];
int n,m;
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>c[i]>>w[i];
	}
	for(int i=1;i<=n;i++){
		for(int u=c[i];u<=m;u++){//这一行与01的区别
			a[u]=max(a[u],a[u-c[i]]+w[i]);
		}
	}
	cout<<a[m];
	return 0;
}
~~~

### 多重背包

多重背包也是 0-1 背包的一个变式。与 0-1 背包的区别在于每种物品有 $k_i$ 个，而非一个。



### Sol

朴素的想法是每一个物品都处理一次。

也可以二进制分组。

### 混合背包

前三种组合在一起。

有的只能取一次，有的能取无限次，有的只能取 $k$ 次。



### Sol

分讨一下，或者全用二进制分组。

### 二维费用背包

选一个物品会消耗两种重量（如经费，时间）。





### Sol

不就是再开一维嘛

### 分组背包

每组中的物品只能选一个。





### Sol

每组内做一次01。见代码。

~~~
#include<bits/stdc++.h>
using namespace std;
int v,n,t;
int x;
int g[205][205];
int i,j,k;
int w[10001],z[10001];
int b[10001];
int dp[10001];
int main(){
    cin>>v>>n;
    for(i=1;i<=n;i++){
        cin>>w[i]>>z[i]>>x;
        t=max(t,x);
        b[x]++;
        g[x][b[x]]=i;
    }
    for(i=1;i<=t;i++){
        for(j=v;j>=0;j--){
            for(k=1;k<=b[i];k++){
                if(j>=w[g[i][k]]){
                    dp[j]=max(dp[j],dp[j-w[g[i][k]]]+z[g[i][k]]);
                }
            }
        }
    }
    cout<<dp[v];
    return 0;
}
~~~

## 状压DP

将一种状态压缩为一个数进行DP。

### P1896 [SCOI2005] 互不侵犯

在 $N \times N$ 的棋盘里面放 $K$ 个国王，使他们互不攻击，共有多少种摆放方案。国王能攻击到它上下左右，以及左上左下右上右下八个方向上附近的各一个格子，共 $8$ 个格子。

对于全部数据，$1 \le N \le 9$，$0 \le K \le N\times N$。





### Sol

用二进制表示上一行国王在哪儿，枚举下一行状态转移。

### [P2704 [NOI2001] 炮兵阵地  ](https://www.luogu.com.cn/problem/P2704)





### Sol

一个炮兵会影响两行，压两行就行。



拓展：插头DP，有时间就讲。



## 树形DP

就是把DP的操作搞到树上。

### P1352 没有上司的舞会

某大学有 $n$ 个职员，编号为 $1\ldots n$。

他们之间有从属关系，也就是说他们的关系就像一棵以校长为根的树，父结点就是子结点的直接上司。

现在有个周年庆宴会，宴会每邀请来一个职员都会增加一定的快乐指数 $r_i$，但是呢，如果某个职员的直接上司来参加舞会了，那么这个职员就无论如何也不肯来参加舞会了。

所以，请你编程计算，邀请哪些职员可以使快乐指数最大，求最大的快乐指数。

对于 $100\%$ 的数据，保证 $1\leq n \leq 6 \times 10^3$，$-128 \leq r_i\leq 127$，$1 \leq l, k \leq n$，且给出的关系一定是一棵树。





### Sol

式子不写了。

### 树上背包：P2014 [CTSC1997] 选课

在大学里每个学生，为了达到一定的学分，必须从很多课程里选择一些课程来学习，在课程里有些课程必须在某些课程之前学习，如高等数学总是在其它课程之前学习。现在有 $N$ 门功课，每门课有个学分，每门课有一门或没有直接先修课（若课程 a 是课程 b 的先修课即只有学完了课程 a，才能学习课程 b）。一个学生要从这些课程里选择 $M$ 门课程学习，问他能获得的最大学分是多少？

( $1 \leq N \leq 300$ , $1 \leq M \leq 300$ )





### Sol

两个做好的背包合并一次是 $n^2$ 的。

每次把子节点的背包合并到父亲上。

### 树上换根

也是dp的一个变种。

给定一个 $n$ 个点的树，请求出一个结点，使得以这个结点为根时，所有结点的深度之和最大。

一个结点的深度之定义为该节点到根的简单路径上边的数量。

对于全部的测试点，保证 $1 \leq n \leq 10^6$，$1 \leq u, v \leq n$，给出的是一棵树。





### Sol

换一次根考虑改变了啥。



## 数位DP

数位是指把一个数字按照个、十、百、千等等一位一位地拆开，关注它每一位上的数字。



### P2602 [ZJOI2010] 数字计数  

给定两个正整数 $a$ 和 $b$，求在 $[a,b]$ 中的所有整数中，每个数码(digit)各出现了多少次。

- 对于 $100\%$ 的数据，保证 $1\le a\le b\le 10^{12}$。



### Sol

$[a,b]$ 可以转化为 $[1,b]-[1,a-1]$

按数位从大到小，贴上界后面就只能取0到上界.不贴上界随便取。

### 不要62

统计一个区间内数位上不能有 4 也不能有连续的 62 的数有多少。



### Sol

$[a,b]$ 可以转化为 $[1,b]-[1,a-1]$

按上述分为贴/不贴上界。加一维0/1表示上一个数是不是6

### windy 数 

不含前导零且相邻两个数字之差至少为 $2$ 的正整数被称为 windy 数。windy 想知道，在 $a$ 和 $b$ 之间，包括 $a$ 和 $b$ ，总共有多少个 windy 数？

对于全部的测试点，保证 $1 \leq a \leq b \leq 2 \times 10^9$。





### Sol

分为贴/不贴上界，维护一下上一位是啥。

