# DP选讲 - に

## 计数DP

相比一般dp求最值或者是否存在这样的情况，计数DP是计算某种方案的数量。DP的过程两者没有本质区别。

------

### 简单例题 1.0

假设你在爬楼梯，每次可以爬一个或两个台阶，给定总的台阶数 $n$ ，问有多少种不同的方法可以爬到楼顶。



### 简单例题 2.0

机器人位于 $n\times m$ 网格的左上角，机器人每次只能向下或向右移动一步，问移动到右下角的路径方案数？

------

计数DP的本质就是要找到一个状态和对应的状态转移，使得满足要求计算所有可能的情况的数量，并且避免重复计算（有重复的一般用容斥解决）。

------

### ACWing900：整数划分

一个正整数可以表示为若干个正整数之和，求将一个正整数 $n$ 划分的方案数。

$n\leq 1000$





### Sol

令 $f_{i,j}$ 为剩下的数为 $i$ ，之前的划分中最大的数为 $j$ 的方案数。

只能向新划分出的数大于 $j$ 的状态转移。



### P2327 [SCOI2005] 扫雷







### Sol

令 $f_{i,0/1,0/1}$ 表示当前考虑了前 $i$ 个雷，第 $i$ 的位置有没有雷，第 $i-1$ 的位置有没有雷。

对应状态转移即可。

### P2051 [AHOI2009] 中国象棋







### Sol

令 $f_{i,j,k}$ 为考虑到第 $i$ 行，有 $j$ 列填了1个棋子，$k$ 列填了2个棋子的方案数。



### CF559C Gerald and Giant Chess





### Sol

直接考虑不能走黑色，数据范围太大不好做。

考虑容斥一下，不走黑色的方案数=总的方案数-经过黑点的方案数

不考虑限制从点 $i$ 走到点 $j$ 的方案数为：$C_{x_i+y_i-x_j-y_j}^{x_i-x_j}$

先把黑点按照坐标排序。

定义 $f_i$ 表示不经过黑点走到第 $i$ 个点的方案数。

那么：$f[i]=C_{x_i+y_i-2}^{x_i-1}-\sum_{j=1}^{i-1}f[j]*C_{x_i+y_i-x_j-y_j}^{x_i-x_j}$

表示随便走到第 $i$ 个点的方案数减去经过前面一个黑点后剩下随便走的方案数。

令 $(h,w)$ 为第 $n+1$ 个黑点，最终答案就是 $f_{n+1}$。



### P5664 [CSP-S2019] Emiya 家今天的饭  

给出一个矩阵，要求每行只能选一个节点，每列选的节点不能超过所有选的节点的一半，不能不选，给出每个节点的选择方案数，求总方案数





### Sol

不考虑限制方案数减去一定超限制的方案数为答案。

因为超限制的要超过总节点的一半，所以只可能有一个超限制且数量比其他种类的大。

于是枚举这一个做dp。

令$f_{i,j,k}$ 为考虑前 $i$ 种，选定的最多的选了 $j$ 个，其他选了 $k$ 个的方案数。复杂度 $n^3m$。

实际上我们不关心最多的和其他的数量，只关心两者的差值，于是可以简化为：

$f_{i,k}$ 表示钦定的最多的和其他的差值是 $k$ 的方案数。





其实就是个数学问题推下式子然后套DP。

还有一些高级计数比如说无向图计数之类的，出必黑题...

## 期望DP

实际就是DP套个期望/概率。

- 期望的一些性质

$ E(X+Y)=E(X)+E(Y)$

$E(XY)=E(X)E(Y)（X，Y相互独立）$

$E(aX+b)=aE(X)+b$

$E(c)=c$



### CF148D Bag of mice







### Sol

设 $f(i,j)$ 表示有 $i$ 只白鼠，$j$ 只黑鼠时A先手胜的概率

初始状态

全白时，显然先手必胜

有一只黑鼠时，先手若抽到黑鼠则后手必胜，所以先手首回合必须抽到白鼠

$f(i,0)=1,f(i,1)=\frac{i}{i+1}$

转移方程 $f(i,j)$

先手抽到白鼠，胜：$\frac{i}{i+j}$

先手抽到黑鼠，后手抽到白鼠，败： $0$

先手抽到黑鼠，后手抽到黑鼠，跑一只白鼠：$\frac{j}{i+j}\times \frac{j-1}{i+j-1}\times \frac{i}{i+j-2}\times f(i-1,j-2)$

先手抽到黑鼠，后手抽到黑鼠，跑一只黑鼠：$\frac{j}{i+j}\times \frac{j-1}{i+j-1}\times \frac{j-2}{i+j-2}\times f(i,j-3)$

$f(i,j)=\frac{i}{i+j}+\frac{j}{i+j}\times \frac{j-1}{i+j-1}\times \frac{i}{i+j-2}\times f(i-1,j-2)+\frac{j}{i+j}\times \frac{j-1}{i+j-1}\times \frac{j-2}{i+j-2}\times f(i,j-3)$

$O(wb)$



### Discovering Gold

t 组数据，每组给出 n 个数，代表 n 个格子的值，现在要从第一个格子出发前往第 n 个格子，每到达一个格子都能扔一次 1~6 的骰子，决定下一步走到哪个位置，若当前位置骰子掷出的值大于n 则重新掷骰子，直到到达第 n 个格子结束，问从最终获得格子上的值的期望值

t<=100 n<=100





### Sol

设 $f_{i}$ 即为到第 $i$ 个格子得到的期望权值。

$f_i=f_{i-1}/6+f_{i-2}/6+...+f_{i-6}/6+Val_i$



### Discovering Gold · 改

有 n 个格子，在第 1∼n−1 个格子上，第 i 个格子上有一个骰子，面值为 $1∼a_i$，投一次骰子，这些面值均匀出现。投到几，就往前走几格。

从 1 号格子出发，求到 n 号格子所要投的骰子个数的数学期望。



### Sol

定义$f_i$ 为从 $n$ 开始走到第 $i$ 个点的期望。

$f_i = (f_{i+1}+..+f_{i+a_i})/a_i+1$ 



可见期望dp可以正推和逆推，有些情况不可以，具体情况具体分析。



### P3232 [HNOI2013] 游走





### Sol

考虑每条边的期望经过次数，次数越多的编号越小就行。

求边的期望经过不太好转移，考虑令$f_u$ 为点 $u$ 的期望经过次数。

则某一条边的期望经过次数为 $g_i=\frac{f_u}{d_u}+\frac{f_v}{d_v}\quad E_i=(u,v),u\neq n, v\neq n$

再写出 $f_u$ 的转移：

$f_u=\sum_{v\in E_u}\frac {f_v}{d_v	}$，其中 $d_v$ 为度数。

第一个点是开始的节点，一开始就走过了，所以$f_1=1+\sum \frac {f_v}{d_v}$

走到点n就结束了，所以 $f_n$ 等于0。

方程组高消就行。



### CF1153F Serval and Bonus Problem  

有一段长为$l$的线段，有$n$个区间，左右端点在$[0,l)$间均匀随机（可能不是整数）

求期望被至少$k$段区间覆盖的长度，对998244353取膜





### Sol

这题我们只关心端点的位置关系，有 $2n$ 个端点把线段分为 $2n+1$ 段。

只要对每一段，计算这一段被至少 $k$ 段区间覆盖的概率。

令 $f[i][j]$ 表示有 $i$ 个端点，第 $i$ 个端点后面的区间被 $j$ 个线段覆盖的方案数。转移直接枚举 $i$ 是一个区间的开始还是结束，如果是结束还要乘 $j$ 转移，表示这个端点可以匹配前面 $j$ 个的任意一个。

顺便维护一个 $0/1$ 表示合法的方案数。最终除以总方案数就是答案。



### [AGC030D] Inversion Sum

给你一个长度为 $n$ 的数列，然后给你 $q$ 个交换或不交换操作（给定交换的位置 $x$ 和 $y$），你可以选择操作或者不操作，问所有情况下逆序对的总和。

答案需要对 $10 ^ 9 + 7$ 取模。

$n\leq 3000$，$q\leq 3000$。

- $ 1\ \leq\ N\ \leq\ 3000 $
- $ 0\ \leq\ Q\ \leq\ 3000 $
- $ 0\ \leq\ A_i\ \leq\ 10^9(1\leq\ i\leq\ N) $
- $ 1\ \leq\ X_i,Y_i\ \leq\ N(1\leq\ i\leq\ Q) $
- $ X_i\neq\ Y_i(1\leq\ i\leq\ Q) $
- 入力はすべて整数である





### Sol

问题其实可以看作求期望的逆序对数，最后乘个 $2^q$ 。

令 $f[i][j]$ 表示位置 $i$ 的数大于位置 $j$ 的数的概率。

改一次只会修改 $O(n)$ 个状态。

如 $f[x][i] = (f[x][i]+f[y][i])/2$。



- 练习题

 P8774 [蓝桥杯 2022 省 A] 爬树的甲壳虫  

 CF1737E

 P8967 追寻 | Pursuit of Dream  



## 插头DP

判断连通性的状态压缩动态规划问题。

适用于各种网格覆盖且允许状压解决的问题。

### P5074 Eat the Trees  

给出 $n \times m$ 的方格，有些格子不能铺线，其它格子必须铺，可以形成多个闭合回路。问有多少种铺法？

 $n,m\ (2 \le n,m \le 12)$。





### Sol

状压DP的升级版，维护一个轮廓线（线上有插头），对插头DP。

~~~c++
#include<bits/stdc++.h>
using namespace std;
#define int long long 
inline int rd(){
	int f=1,j=0;
	char w=getchar();
	while(w>'9'||w<'0'){
		if(w=='-')f=-1;
		w=getchar();
	}
	while(w>='0'&&w<='9'){
		j=(j<<3)+(j<<1)+w-'0';
		w=getchar();
	}
	return f*j;
}
const int N=15,M=4096;
int T,n,m,len,f[N][N][M];
bool v[N][N];
void pri(int x){
	if(x)cout<<(x&1),pri(x/2);
	return ;
}
void work(){
	n=rd(),m=rd(),len=(1<<(m+1));
	memset(v,0,sizeof(v)),memset(f,0,sizeof(f));
	for(int i=1;i<=n;i++)for(int j=1;j<=m;j++)v[i][j]=rd();
	f[0][m][0]=1;
	for(int i=1;i<=n;i++){
		for(int j=0;j<len;j++)f[i][0][j<<1]=f[i-1][m][j];
		for(int j=1;j<=m;j++){
			for(int k=0;k<len;k++){
				bool a=((k>>(j-1))&1),b=((k>>(j))&1);
				if(!v[i][j]){
					if(!a&&!b)f[i][j][k]+=f[i][j-1][k];
				}
				else if(a&&b&&v[i+1][j]&&v[i][j+1])f[i][j][k]+=f[i][j-1][k^(1<<(j-1))^(1<<j)];
				else if(!a&&b&&v[i][j+1])f[i][j][k]+=f[i][j-1][k]+f[i][j-1][k^(1<<(j-1))^(1<<j)];
				else if(a&&!b&&v[i+1][j])f[i][j][k]+=f[i][j-1][k]+f[i][j-1][k^(1<<(j-1))^(1<<j)];
				else if(!a&&!b)f[i][j][k]+=f[i][j-1][k^(1<<(j-1))^(1<<j)];
			}
		}
	}
	printf("%lld\n",(f[n][m][0])?f[n][m][0]:0);
	return ;
}
signed main(){
	T=rd();
	while(T--)work();
	return 0;
}
~~~





其他的题都是更复杂情况的讨论和对于轮廓线的转化了。