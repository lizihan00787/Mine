# 引入

给定两个点，求过这两个点的一次函数。

很简单，待定系数法即可。

--------

给定三个点，求过这三个点的二次函数。

同样，待定系数法即可。

--------

给定四个点，求过这四个点的三次函数。

同上。

......

给定 $n+1$ 个点，求过这 $n+1$ 个点的 $n$ 次函数。

？？？

# 拉格朗日插值

拉格朗日插值正是用于求解上面的问题的。

设已知这 $n+1$ 个点为 $(x_i,y_i)$。

设这个函数为 $n$ 次多项式 $L$。

设 $L_i(x)$ 是一个 $n$ 次多项式，且满足
$$
\begin{cases}
L_i(x_i)=y_i\\
L_i(x_j)=0\ \ \ (i\not=j)
\end{cases}
$$
即 $L_i(x)$ 仅满足 $x_i$ ，而其他的 $x_j$ 则必须对应为零。

那么 $L=\sum\limits^{n+1}_{i=1}{L_i}$。

如何构造 $L_i$ 呢？

可以考虑先构造 $L_i'(x)$，使其满足
$$
\begin{cases}
L_i(x_i)=1\\
L_i(x_j)=0\ \ \ (i\not=j)
\end{cases}
$$
那么 $L_i=y_iL_i'$。

因为 $L_i'(x)$ 的取值只有 $0$ 和 $1$，那么可以考虑构造一个分式，使得当 $x=x_i$ 时，分式的分子分母相等，即分式的值为 $1$，当 $x\not=x_i$ 时，分式的分子为零，即分式的值为 $0$。

可以得出 $L_i'(x)$ 可以是下面的多项式：

$$\frac{\prod\limits^{n+1}_{j=1}{(x-x_j)(i\neq j)}}{\prod\limits^{n+1}_{j=1}{(x_i-x_j)(i\neq j)}}$$

那么 $L_i(x)$ 就应该是:

$$yi\frac{\prod\limits^{n+1}_{j=1}{(x-x_j)(i\neq j)}}{\prod\limits^{n+1}_{j=1}{(x_i-x_j)(i\neq j)}}$$

因为 $L=\sum\limits^{n+1}_{i=1}{L_i}$，所以 $L(x)$ 应该为：

$$\sum\limits^{n+1}_{i=1}{(y_i{\frac{\prod\limits^{n+1}_{j=1}{(x-x_j)(i\neq j)}}{\prod\limits^{n+1}_{j=1}{(x_i-x_j)(i\neq j)}}})}$$

这就是拉格朗日插值法。









#### CF622F The Sum of the k-th Powers

求自然数前 $n$ 项的 $k$ 次方和。

$n\leq10^9,k\leq10^5$。















#### Sol

首先，设 $f(n)=\Sigma^{n}_{i=1}{i^k}$。

然后利用差分表法可以得知，这是一个关于 $n$ 的 $k+1$ 次多项式。

那么要求出这个多项式就只需要取 $k+2$ 个在函数 $f(n)$ 上的点，然后利用拉格朗日插值法即可计算出该多项式。

最后将 $n$ 代入该多项式即可。







#### P8290 [省选联考 2022] 填树

有一棵 $n$ 个节点的无根树，刚开始树上每个节点的权值均为 $0$。KK 想对这棵树进行一些修改，他会任选一个节点作为初始的当前节点，然后重复以下动作：

1. 将当前节点 $i$ 的权值修改为一个**正整数** $x$，需满足 $l_i \leq x \leq r_i$。其中 $l_i, r_i$ 是输入中给出的两个正整数。
2. 结束修改过程，或移动到一个与当前节点相邻的权值为 $0$ 的节点（如果不存在这样的节点，则必须结束修改过程）。

现在 KK 有两个问题：

1. 在修改结束后，可以得到多少棵不同的树，满足树上**非零权值**的最大值和最小值的差小于等于 $K$？其中 $K$ 是输入中给出的一个正整数。

2. 这些满足条件的树的权值之和为多少？（树的权值定义为这棵树上所有节点的权值之和）

你需要输出这两个问题的答案模 $10^9 + 7$。我们认为两棵树不同当且仅当至少存在一个节点的权值不同。

温馨提示：

1. KK 至少会修改一个节点（初始节点）。
2. 实质上 KK 会修改树上的任意一条路径，最后需要满足这条路径上的点的权值最大值和最小值之差小于等于 $K$。

$1 \leq n \leq 200$，$1 \leq l_i \leq r_i \leq {10}^9$，$1 \leq K \leq {10}^9$。















#### Sol

首先 $\max-\min\leq k$ 的条件如果直接枚举上下界去填会算重，但是可以减掉 $k-1$ 的答案来去重。

钦定一条链之后算答案相当于每个节点与给定区间的交集大小求积就是方案数。

所有链的答案之和可以通过 dp 来获得。

注意到当下界 $x$ 增加时，每个交集大小要么不变要么线性变化，因此他们的乘积应当是最多 $x$ 的 $n$ 次多项式。

所以对于每一段我们都只求 $n+2$ 个点值就能求出这段的总方案数了。

权值之和相当于把交集替换为交集中的数之和，这个东西与 $x$ 是二次关系，所以需要求 $2n+2$ 个点值就可以了。







# 线性基

回忆一下线性代数中的内容，但是向量每一维只有 $0$ 或 $1$，并且向量的加法理解为每一位对应异或和。

如果一组线性无关的向量可以张成一个空间，那么这组向量称为这个空间的线性基。换句话说，这个空间中每一个向量都可以由线性基中的向量线性组合出来。

比如 $a=(1,0,1),b=(0,1,1),c=(0,1,0)$ 就可以张出整个三维空间：
$$
\begin{aligned}
(0,0,1)&=b+c
\\
(0,1,0)&=c
\\
(0,1,1)&=b
\\
(1,0,0)&=a+b+c
\\
(1,0,1)&=a
\\
(1,1,0)&=a+b
\\
(1,1,1)&=a+c
\end{aligned}
$$
给出一组向量，如何找出一组线性基，使其张成的空间就是这一组向量张成的空间呢？

```cpp
struct xxj{
    int w[40];
    void insert(int x) {
        for (int i = 31; ~i; i--) {
            if (x >> i & 1) {
                if (w[i]) x ^= w[i];
                else {
                    w[i] = x;
                    break;
                }
            }
        }
    }
}
```

如何求出这个空间中字典序最大的向量？

```cpp
int mx() {
    int ans = 0;
    for (int i = 31; ~i; i--) {
        if (!w[i]) continue;
        ans = max(ans, ans ^ w[i]);
    }
    return ans;
}
```

如何求出空间内的第 $k$ 大的向量？

```cpp
int kth(int k) {
    int ans = 0, cnt = -1;
    for (int i = 31; ~i; i--) if (w[i]) ++cnt;
    for (int i = 31; ~i; i--, --cnt) {
        if (!w[i]) continue;
        int t = ans ^ w[i];
        if (k > (1 << cnt)) ans = min(ans, t), k -= (1 << cnt);
        else ans = max(ans, t);
    }
    return ans;
}
```







#### [SCOI2016] 幸运数字

A 国共有 $n$ 座城市，这些城市由 $n - 1$ 条道路相连，使得任意两座城市可以互达，且路径唯一。每座城市都有一个幸运数字，以纪念碑的形式矗立在这座城市的正中心，作为城市的象征。

一些旅行者希望游览 A 国。旅行者计划乘飞机降落在 $x$ 号城市，沿着 $x$ 号城市到 $y$ 号城市之间那条唯一的路径游览，最终从 $y$ 城市起飞离开 A 国。在经过每一座城市时，游览者就会有机会与这座城市的幸运数字拍照，从而将这份幸运保存到自己身上。然而，幸运是不能简单叠加的，这一点游览者也十分清楚。他们迷信着幸运数字是以异或的方式保留在自己身上的。

例如，游览者拍了 $3$ 张照片，幸运值分别是 $5, 7, 11$，那么最终保留在自己身上的幸运值就是 $5 \operatorname{xor} 7 \operatorname{xor} 11 = 9$。

有些聪明的游览者发现，只要选择性地进行拍照，便能获得更大的幸运值。例如在上述三个幸运值中，只选择 $5$ 和 $11$ ，可以保留的幸运值为 $14$ 。现在，一些游览者找到了聪明的你，希望你帮他们计算出在他们的行程安排中可以保留的最大幸运值是多少。

$n \leq 2 \times 10^4, q \leq 2 \times 10^5, G_i \leq 2^{60}$。

















#### Sol

直接树链剖分维护维护线性基的话那就是 4 只 $\log$。

注意到线性基算重也是可以的，所以可以考虑倍增 $lca$ 的同时记一下线性基就可以做到 3 只 $\log$。再稍微注意一下可以做到 $O(n\log^3n+q\log^2n)$，能够惊险的通过。









#### P4151 [WC2011] 最大XOR和路径

考虑一个边权为非负整数的无向连通图，节点编号为 $1$ 到 $n$，试求出一条从 1 号节点到 $n$ 号节点的路径，使得路径上经过的边的权值的 XOR 和最大。

路径可以重复经过某些点或边，当一条边在路径中出现了多次时，其权值在计算 XOR 和时也要被计算相应多的次数。

$n\leq5\times10^4,m\leq10^5$。

















#### Sol

随便挑一条 $1$ 到 $n$ 的路径，发现其他路径异或上这条路径剩下的边就是一些环。

怎么求出图里所有的环？

事实上我们找一棵生成树，只考虑包含一条非树边与若干树边的环，这些环相互异或就可以得到所有环。

因此我们把这些环扔进线性基里，看看能让刚刚随便选的路径最大能增大到多大就可以了。



















#### P4301 [CQOI2013] 新Nim游戏

太困了，下次再写了。